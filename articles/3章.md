## 3-1 略

## 3-2 CORS 跨域请求限制与解决


//Content-Type代表发送端发送的实体数据的数据类型。

```
'Content-Type':'text/html'  // HTML格式
'Content-Type':'text/plain' //纯文本格式      
```

如何模拟 cors:

	先起两个 server，一个8888，一个8887，
	8888服务中，读取 html 的内容，
	html中发送了一个 ajax 请求，这个请求的 url 是服务，8887




实践表明：    

	浏览器在发送请求的时候，并不知道是跨域的，所以请求都是发送出去的    
	并且接受返回内容，服务器也是有数据返回的  
	但是浏览器接受数据返回时，没有头 Access-Control-Allow-Origin: '*'  
	浏览器会忽略请求返回内容，并在控制台报错    

是否必须在访问的服务器上，加上， Access-Control-Allow-Origin: '*'   
不是，还可以通过 jsonp    
*代表：任何服务，任何域名的页面，都可以访问这个服务。

jsonp原理：

浏览器允许，向link、img、script 标签，在标签上加载资源的时候，是允许加载的。



## 3-3 cors 预请求

> Q： 是否服务端头，加上了 Access-Control-Allow-Origin: '*'  ，任何客户端访问都可以了呢？

不是

在跨域时，默认允许的方法只有，get、head、post，其他方式都需要有预请求的。

允许的 Content-Type 也是有限制的， text/plain, multipart/form-data, application/x-www-form-urlencoded，除此外的 需要预请求，验证后才被允许。

请求头的限制，自定义的请求头是不被允许的。

```
fetch('http://localhost:8887', {
    method: 'POST',
    headers: {
      'X-Test-Cors': '123'
    }
  })
```


> 什么是预请求？

如果我们允许，自定义头，需要添加新的头。

```
Access-Control-Allow-Origin: '*' ,
Access-Control-Allow-Headers: 'X-Test-cors' 

```

当我们添加 自定义请求头时，虽然说跨域，但是返回 200， 类型 options
实际上是有返回的，但是浏览器因为安全策略问题，不允许这个请求的返回



通过 options 请求，获取服务端允许的认可，然后再实际发送 post 请求。

```
// 添加服务端允许的方法。Access-Control-Allow-Methods。
// 跨域请求的最长请求时间。通过 Access-Control-Max-Age 上方配置项进行跨域访问的请求时间，1000秒内，跨域访问不需要再发送预请求，就可以直接访问。

第一次需要预请求，5秒后，再次请求，发现这次没有需要预请求了。

response.writeHead(200, {
    'Access-Control-Allow-Origin': 'http://127.0.0.1:8888',
    'Access-Control-Allow-Headers': 'X-Test-Cors',
    'Access-Control-Allow-Methods': 'POST, PUT, DELETE',
    'Access-Control-Max-Age': '1000'
  })
```


## 3-4 cache-control


public: 
	
	这个http 请求，返回的内容，所经过的任何路径，包括 http代理服务器 和 发出请求的 客户端浏览器，都可以对 返回内容进行缓存
	
	任何地方都可以缓存

private
	
	只有发起请求的浏览器，可以缓存

no-cache

	可以在本地缓存，可以在代理服务器缓存，但是这个缓存要服务器验证才可以使用

no-store
	
	彻底得禁用缓冲，本地和代理服务器都不缓冲，每次都从服务器获取



max-age = '60' 
	
	60秒后，缓存内容会过期

s-maxage = '60'
	
	只有在代理服务器端才会生效。在浏览器端，还是读取 max-age 作为到期时间。
	如果在 代理服务器，有两个值，那么 s-maxage 生效

max-stale = '60'
	
	即使缓存过期了，只要在 60秒内，还是可以使用缓存，不需要从服务器获取新内容

must-revalidate
	
	即使 max-age 缓存可用，还是要发送验证，才能用这个缓存
	
proxy-revalidate
	
	
no-transform
	
	代理服务器对数据，不需要操作




例子：
	浏览器如何读取本地缓存？

注意：  把 控制台的 disabled cache 钩子，去掉选中。

如何前端更新缓存？
	
	如果url没有变，而 缓存没有过期，是不会从服务端拉去新文件的。
	
	我们希望浏览器缓存我们的静态资源文件，js、css、图片等。但是我们不希望服务端内容更新后，客户端还是使用缓存。
	 
	文件打包完成后，根据内容生成 hash 码，可以在内容改变后，嵌入在 html 中的路径有变化，重新请求服务器，而不是从缓存中读取，从而达到更新静态缓存的目的。
	
	

## 3-5 Last-Modified、Etag （多看几遍



	浏览器，创建请求，  
	开始先从本地缓存中找
		命中，本地缓存返回
		未命中，代理缓存中
			如果命中，返回，经过本地缓存，返回服务器
			如果没有，发送服务器请求
			

客户端： if-modified-since
	
	服务端会读取这个字段，对比 last-modified  后，来确定是否需要更新

if-none-match
	
	etag 根据文件内容生成的签名，对内容进行hash计算，得到一个唯一值
	
	配合服务端的 etag, 如果两个相同，不需要返回新的内容


服务端先设置，etag、Last-Modified值，客户端在下次发送请求的时候，会带上
if-none-match 和 if-modified-since 值。
	
	
				
			
## 3-6  cookie 和 session	


cookie 有哪些属性
	
	max-age，有效时间是多长
	expires 设置过期时间，  注意，不是缓存过期时间！！！
	
	secure 只在 https 的时候发送
	
	httpOnly 无法通过 document.cookie 访问。 


通过 Set-Cookie，设置，

1. id 会在两秒内过期，所以客户端, 请求头中的 cookie，只有2个 key value 值
2. 设置abc属性，HttpOnly, 

```
response.writeHead(200, {
      'Content-Type': 'text/html',
      'Set-Cookie': ['id=123; max-age=2', 'abc=456 ; HttpOnly', domain=test.com'] 
    })
```


## 3-7 http 长链接

设置 timeout 过多少秒后，在这个tcp 连接上，没有新请求，断开 tcp 连接

connectionID 区分 tcp连接，






 

